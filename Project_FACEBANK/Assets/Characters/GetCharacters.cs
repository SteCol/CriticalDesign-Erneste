using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEditor;
using System.IO;
using System;
using System.Linq;

public class GetCharacters : MonoBehaviour
{
    public bool GetCharactersComplete = false;

    [Header("A Whole Bunch Of Lists")]
    public string[] allPaths;
    public List<string> paths;
    //public List<string> words;
    public List<TextAsset> characterFiles;

    [Header("Controls")]
    public bool getFiles;
    public bool getCharacters;
    public bool getInfo;
    public bool getDialog;
    public bool getQuestions;
    public bool getAnswers;
    public bool getStatusUpdates;
    public bool debug;

    [Header("Final CHaracters List")]
    public List<Character> characters = new List<Character>();




    // Use this for initialization
    void Start()
    {
        //Gets the character.txt files.
        if (getFiles)
            GetFiles();


        //Start of the descipherer.
        if (getFiles)
            GetCharacter();

        CheckFollowThrough();

        GetCharactersComplete = true;

    }

    public void GetFiles()
    {
        paths.Clear();
        allPaths = Directory.GetFiles(Application.dataPath, "*", SearchOption.AllDirectories); //ALL the files in the assets folder.

        foreach (string p in allPaths)
        {
            if (p.Contains("Character_") && !p.Contains("meta")) //Narrows down ALL the files to only the Character.txt files.
            {
                paths.Add(p);
                Debug(p);
            }
        }
    }


    public void GetCharacter()
    {
        for (int c = 0; c < paths.Count; c++) //Amount of paths = amount of files found = amount of characters.
        {
            Debug("_________________________________________________________________________________________________");
            Debug("Start of Loop: " + c);

            //Gets the file names from the paths and reformats them to be readable by Resource.Load.
            string output = paths[c].Substring(paths[c].IndexOf(',') + 1); //to get a 'Characters/Characters.txt path' (to be ready by Resoures.Load) I placed a ',' (not used in any other path).
            Debug(output);
            output = output.Substring(0, output.Length - 4); //Removes '.txt'
            //print(output);

            characterFiles.Add((TextAsset)Resources.Load("," + output, typeof(TextAsset))); //Takes the paths generated by 'output' and gets the Character.txt files.

            characters.Add(new Character()); //For each Characters.txt file found make a new entry in the list.
            string[] splitString = characterFiles[c].text.Split(new string[] { "\n" }, StringSplitOptions.None); //Get each seperate line from the Characters.txt files.
            Debug("Amount of lines in " + characterFiles[c].name + "'s file: " + splitString.Length.ToString());


            for (int s = 0; s < splitString.Length; s++) // 's' = amount of sentences.
            {
                //Debug("Line " + s + ": " + splitString[s]);

                //This box gets all the info per line. Might change later.
                if (getInfo && splitString[s].Contains("[Info]"))
                {
                    Debug("Found [Info] for: " + splitString[s + 1]);

                    Level1Debug("Found name: " + splitString[s + 1]);
                    characters[c].name = splitString[s + 1];
                    Level2Debug("Name for Character " + c + " (" + characters[c].name + ") " + "is now: " + characters[c].name);

                    Level1Debug("Found value: " + splitString[s + 2]);
                    characters[c].value = splitString[s + 2];
                    Level2Debug("Value for Character " + c + " (" + characters[c].name + ") " + "is now: " + characters[c].value);

                    Level1Debug("Found info: " + splitString[s + 3]);
                    characters[c].info = splitString[s + 3];
                    Level2Debug("Info for Character " + c + " (" + characters[c].name + ") " + "is now: " + characters[c].info);

                }

                //Here come the dialog.

                if (getDialog && splitString[s].Contains("[Dialog]"))
                {
                    Debug("Found [Dialog] for: " + characters[c].name);

                    for (int r = 0; r < splitString.Length; r++)
                    {
                        for (int q = 0; q < 20; q++) //Amount of questions to check.
                        {
                            if (splitString[r].Contains("+Q" + q.ToString()))
                            {
                                characters[c].questions.Add(new Question(splitString[r], false)); //Adds a question to the list with the string d and a 'answered' value of false. So, an unaswered question.
                                Level2Debug("Added question '" + splitString[r] + "' to " + characters[c].name);
                                

                                for (int a = 1; a < 10; a++) //Amount of answers to check.
                                {

                                    

                                    if (splitString.Length > (r + a))
                                    {
                                        if (splitString[r + a].Contains("+A" + q.ToString() + "." + a.ToString())) //CHeck is the line it's checking has an answer
                                        {

                                            if (splitString[r + a].Contains("[Q")) //Checks if the dialoug has a [Qx] (next dialoug) identifier. If not it'll give 666 value (I doubt we'll ever have more than 666 questions)
                                                                                   //If the value will be 666 there won't be a next dialog or a timer will start for when you recieve the next chat message.
                                            {
                                                //Get the int value out of the [Qx] identifier
                                                string nextQ = splitString[r + a].Substring(splitString[r + a].IndexOf('[') + 2);
                                                string[] nextQArray = nextQ.Split(']');
                                                Level4Debug("Found value for NextQuestion for " + splitString[r + a] + nextQArray[0]);

                                                characters[c].questions[q - 1].answers.Add(new Answer(splitString[r + a], int.Parse(nextQArray[0])));
                                            }
                                            else {
                                                characters[c].questions[q - 1].answers.Add(new Answer(splitString[r + a], 666));
                                            }

                                            Level3Debug("Added answer '" + splitString[r + a] + "' to " + characters[c].name);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                if (getStatusUpdates && splitString[s].Contains("[StatusUpdates]"))
                {
                    Debug("Found " + splitString[s]);
                    for (int i = 0; i < 20; i++) //amount of thimes to check for status updates;
                    {
                        if (splitString.Length > (s + i))

                            if (splitString[s + i].Contains("+SU"))
                            {
                                characters[c].statusUpdates.Add(new StatusUpdate(splitString[s + i]));
                            }
                    }
                }
            }
        }
    }

    public void CheckFollowThrough() {
        Debug("________________________________________________________________________________");
        Debug("CheckFollowthrough");

        for (int c = 0; c < characters.Count; c++)
        {
            for (int q = 0; q < characters[c].questions.Count; q++)
            {
                Debug("Checking: " + characters[c].questions[q].Q);
                if (characters[c].questions[q].Q.Contains("[FollowThrough [Q"))
                {
                    //string nextQ = characters[c].questions[q].Q.Substring(characters[c].questions[q].Q.IndexOf(']') + 2);
                    string[] nextQArray = characters[c].questions[q].Q.Split(']');
                    for (int n = 0; n < nextQArray.Length; n++)
                    {
                        Level1Debug("nextQArray pos " + n + ": " + nextQArray[n]);
                    }

                    Level2Debug(nextQArray[0].Substring(nextQArray[0].LastIndexOf('[') + 2));

                    Level4Debug("Found FollowThrough value for " + characters[c].questions[q].Q + " in  " + characters[c].name + ": " + nextQArray[0].Substring(nextQArray[0].LastIndexOf('[') + 2));


                    characters[c].questions[q].followThrough = int.Parse(nextQArray[0].Substring(nextQArray[0].LastIndexOf('[') + 2));
                }
                else {
                    characters[c].questions[q].followThrough = 666;
                }
            }
        }
    }


    public void Debug(string message)
    {
        if (debug)
            print(message);
    }

    public void Level1Debug(string message)
    {
        if (debug)
            print("|--- " + message);
    }

    public void Level2Debug(string message)
    {
        if (debug)
            print("    |--- " + message);
    }

    public void Level3Debug(string message)
    {
        if (debug)
            print("        |--- " + message);
    }

    public void Level4Debug(string message)
    {
        if (debug)
            print("            |--- " + message);
    }



}